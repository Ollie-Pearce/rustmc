#!/usr/bin/env bash
set -euo pipefail

MIXED_LANGUAGE=false
DEPDIR=$(pwd)

# parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    --ffi)
      MIXED_LANGUAGE=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# now $1 should be the project path
if [[ $# -lt 1 ]]; then
  echo "Target Cargo Project not supplied. Exiting"
  exit 1
fi

TARGET_RUST_PROJECT=$1

make

if [ "$#" -lt 1 ]; then
	echo "Target Cargo Project not supplied. Exiting"
	exit 1
fi

grep -P '^@[^ ]+ = external (thread_local )?global' combined_old.ll \
  | sed -E 's/^@("?[^" =]+).*/\1/' > extern_globals.txt

EXTERNS_ABS="$(realpath extern_globals.txt)"

OLD_PWD="$(pwd)"

cd /home/ollie/Desktop/RustMC/rust/build/x86_64-unknown-linux-gnu

EXTERNS_FILE="$EXTERNS_ABS"

# 1. Dump all symbol tables in parallel
ALL_NM_OUTPUT="$(
  find . -type f \( -name '*.o' -o -name '*.rlib' \) -print0 \
  | xargs -0 -P"$(nproc)" -I{} sh -c '
        f="$1"
        llvm-nm --quiet --defined-only --print-file-name "$f" 2>/dev/null
      ' sh {}
)"

SANITISED_PATTERNS="$(mktemp)"
grep -v '^$' "$EXTERNS_FILE" > "$SANITISED_PATTERNS"

printf '%s\n' "$ALL_NM_OUTPUT" \
| rg -F -f "$SANITISED_PATTERNS" --no-line-number --no-heading \
| cut -d: -f1 \
| sort -u \
| while IFS= read -r p; do realpath "$p"; done \
> matched_files_abs.txt

echo "Matched extern globals in files:"
cat matched_files_abs.txt
echo "\n ------------------------------ \n"

INPUT_LIST="matched_files_abs.txt"

while IFS= read -r rlib; do
  # skip blank lines
  [ -z "$rlib" ] && continue

  # skip if not an .rlib
  case "$rlib" in
    *.rlib) ;;
    *) continue ;;
  esac

  outdir="${rlib%.rlib}.bcdir"
  mkdir -p "$outdir"
  tmp="$(mktemp -d)"

  # extract only .o members into a temp dir
  llvm-ar t "$rlib" | rg '\.o$' | while IFS= read -r m; do
    llvm-ar p "$rlib" "$m" > "$tmp/$m"
  done

  # for each .o, dump embedded bitcode and disassemble
  (
    cd "$tmp"
    find . -type f -name '*.o' -print0 \
    | while IFS= read -r -d '' f; do
        if llvm-readelf -S "$f" | rg -q '\.llvmbc'; then
          b="$outdir/${f#./}"
          b="${b%.o}"
          mkdir -p "$(dirname "$b")"
          llvm-objcopy --dump-section .llvmbc="${b}.bc" "$f"
          llvm-dis "${b}.bc" -o "${b}.ll"
        fi
      done
  )

  # optional: clean temp dir
  rm -rf "$tmp"

done < "$INPUT_LIST"

TMP_RESULTS="$(mktemp)"

grep -v '^$' "$EXTERNS_FILE" | while IFS= read -r sym; do
  # collect all .ll files that mention this symbol
  rg -l --glob '*.ll' -F "$sym" . | while IFS= read -r file; do
    # skip whole file if it has an external decl of this symbol
    # reject both @sym = external ... and @"sym" = external ...
    if rg -q -F "$sym = external" "$file"; then
      continue
    fi
    if rg -q -F "\"$sym\" = external" "$file"; then
      continue
    fi

    # extract candidate lines
    rg -F "$sym" "$file" \
    | rg ' global ' \
    | rg -v -F "$sym = external" \
    | rg -v -F "\"$sym\" = external" \
    | sed -E 's/(align [0-9]+).*$/\1/' \
    >> "$TMP_RESULTS"
  done
done

sort -u "$TMP_RESULTS" > $OLD_PWD/combined_extern_globals_definitions.ll

cd "$OLD_PWD"

tmp="$(mktemp)"
grep -v ' = external' "combined_extern_globals_definitions.ll" > "$tmp"
mv "$tmp" "$OLD_PWD/combined_extern_globals_definitions.ll"

/usr/bin/llvm-link-18 -S --internalize --override=combined_extern_globals_definitions.ll -o override/my_pthread.ll override/my_pthread.ll

# Rename #[test] functions so they are all unique
python_script="rename_duplicate_rust_tests.py"

# Loop until the output is not "No duplicates found or no changes required."
while true; do
    output=$(python3 "$python_script")

    if [ "$output" = "No duplicates found or no changes required." ]; then
        echo "Output unchanged"
        
        break
    fi

    echo "Output changed: $output"
    sleep 1  # Sleep for a second to avoid running continuously without pause
done

cd $TARGET_RUST_PROJECT

rm -rf target-ir
mkdir -p target-ir

PROJECT_NAME=$(grep -m1 '^name\s*=' Cargo.toml | sed -E 's/name\s*=\s*"([^"]+)".*/\1/')
PROJECT_NAME=$(printf '%s' "$PROJECT_NAME" | tr '-' '_')
echo "$PROJECT_NAME"

# Add #[no_mangle] to #[test] functions that do not have it
find . -name "*.rs" | while read -r file; do
  awk '
    {
      if ($0 ~ /^[[:space:]]*#\[test\]/ && prev !~ /^[[:space:]]*#\[no_mangle\]/) {
        print "#[no_mangle]"
      }
      print
      prev = $0
    }
  ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
done

# Collect Rust test file paths
echo "Collecting integration tests..."
INTEGRATION_TEST_FILES="$DEPDIR/integration_test_files.txt"
: > "$INTEGRATION_TEST_FILES"

find . -path "*/tests/*.rs" -type f | sort > "$INTEGRATION_TEST_FILES"

# For each test file, extract names of functions annotated with #[test]
TEST_FN_DIR="$DEPDIR/test_functions/${PROJECT_NAME}"
mkdir -p "$TEST_FN_DIR"

while read -r file; do
  base="$(basename "${file%.*}")"
  awk '
    BEGIN { seen_test = 0 }
    /^[[:space:]]*#\[test\]/          { seen_test = 1; next }
    /^[[:space:]]*#\[/ && $0 !~ /#\[test\]/ { next }
    seen_test && /^[[:space:]]*(pub[[:space:]]+)?(async[[:space:]]+)?fn[[:space:]]/ {
      line = $0
      sub(/^[[:space:]]*(pub[[:space:]]+)?(async[[:space:]]+)?fn[[:space:]]+/, "", line)
      sub(/\(.*/, "", line)      # strip args
      gsub(/[[:space:]]/, "", line)
      print line
      seen_test = 0
      next
    }
    /^[[:space:]]*$/ { seen_test = 0 }
  ' "$file" > "$TEST_FN_DIR/${base}.txt"
done < "$INTEGRATION_TEST_FILES"

echo "Collecting unit tests..."
UNIT_TEST_FILE="$DEPDIR/unit_test_functions.txt"
> "$UNIT_TEST_FILE"

find . -path "./tests" -prune -o -name "*.rs" -print | while read -r file; do
  awk '
    BEGIN { in_test = 0 }
    /^[[:space:]]*#\[test\]/ { in_test = 1; next }
    in_test && /^[[:space:]]*fn[[:space:]]+[a-zA-Z0-9_]+/ {
      if (match($0, /fn[[:space:]]+([a-zA-Z0-9_]+)/, m)) {
        print m[1]
      }
      in_test = 0
    }
  ' "$file"
done >> "$UNIT_TEST_FILE"

echo "Unit test function names written to: $UNIT_TEST_FILE"
cargo clean

# Create temp file for output
cargo_output_file=$(mktemp)

mkdir -p test_traces
rm -rf "test_traces/${PROJECT_NAME}"/*.txt
mkdir -p "test_traces/${PROJECT_NAME}"

cd ../..

echo "pwd is: $(pwd)"

cd $DEPDIR

 echo "just changed to depdir:"
  echo "pwd is: $(pwd)"

/usr/bin/llvm-link-18 --internalize --override=$DEPDIR/override/my_pthread.ll -o combined_old.bc combined_old.bc

/usr/bin/opt-18 -mtriple=x86_64-unknown-linux-gnu -expand-reductions combined_old.bc -o combined.bc

echo " "
echo " ================= Verifying Unit Tests ================= "
echo " "

while read -r test_func; do
  echo "Verifying test function: $test_func"
  timeout 1000s ./genmc --mixer \
          --disable-assume-propagation \
          --disable-load-annotation \
          --disable-confirmation-annotation \
          --disable-spin-assume \
          --program-entry-function="$test_func" \
          --disable-estimation \
          --print-error-trace \
          --disable-stop-on-system-error \
          --unroll=2 \
          combined.bc > "test_traces/${PROJECT_NAME}/${test_func}_verification.txt" 2>&1

  if [ $? -eq 124 ]; then
      echo "TIMEOUT" >> "test_traces/${PROJECT_NAME}/${test_func}_verification.txt"
  fi
done < "$UNIT_TEST_FILE"

echo " "
echo " ================= Finished Verifying Unit Tests ================= "
echo " "

#./genmc --mixer --transform-output=myout.ll --print-exec-graphs --disable-function-inliner --program-entry-function="test_as_ptr_1_1 --disable-estimation --print-error-trace --disable-stop-on-system-error --unroll=2 combined.ll


#/usr/bin/time -v ./genmc --mixer --transform-output=myout.ll --print-exec-graphs --disable-function-inliner --disable-assume-propagation --disable-load-annotation --disable-confirmation-annotation --disable-spin-assume --program-entry-function="test_as_ptr_1_1" --disable-estimation --print-error-trace --disable-stop-on-system-error --unroll=2 combined.ll


# Above gives us:
# LLVM ERROR: Could not resolve external global address: _ZN3std4sync4mpmc7context7Context4with7CONTEXT29_$u7b$$u7b$constant$u7d$$u7d$28_$u7b$$u7b$closure$u7d$$u7d$3VAL17h1e32d3ce09f1da45E

cd test_traces/${PROJECT_NAME}/

file_count=$(ls | wc -l)

success_search_string="Verification complete. No errors were detected."
success_count=$(grep -rl "$success_search_string" . | wc -l)
echo "Verification success: $success_count / $file_count" > ../../test_results/${PROJECT_NAME}_summary.txt

unsupported_intrinsic_string="LLVM ERROR: Code generator does not support intrinsic function"
unsupported_intrinsic_count=$(grep -rl "$unsupported_intrinsic_string" . | wc -l)
echo "Unsupported intrinsic errors: $unsupported_intrinsic_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

uninitialised_read_string="Error: Attempt to read from uninitialized memory!"
uninitialised_read_count=$(grep -rl "$uninitialised_read_string" . | wc -l)
echo "Uninitialised read errors: $uninitialised_read_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

no_entry_string="ERROR: Could not find program's entry point function!"
no_entry_count=$(grep -rl "$no_entry_string" . | wc -l)
echo "No entry point errors: $no_entry_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

external_function_string="ERROR: Tried to execute an unknown external function:"
external_function_count=$(grep -rl "$external_function_string" . | wc -l)
echo "External function errors: $external_function_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

visit_atomic_rmw_string="visitAtomicRMWInst"
visit_atomic_rmw_count=$(grep -rl "$visit_atomic_rmw_string" . | wc -l)
echo "AtomicRMW errors: $visit_atomic_rmw_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

external_address_string="LLVM ERROR: Could not resolve external global address:"
external_address_count=$(grep -rl "$external_address_string" . | wc -l)
echo "External address errors: $external_address_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

memset_promotion_string="ERROR: Invalid call to memset()!"
memset_promotion_count=$(grep -rl "$memset_promotion_string" . | wc -l)
echo "Memset promotion errors: $memset_promotion_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

ilist_iterator_string="Assertion \`!NodePtr->isKnownSentinel()' failed."
ilist_iterator_count=$(grep -rFl -- "$ilist_iterator_string" . | wc -l)
echo "ilist iterator errors: $ilist_iterator_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

constant_unimplemented_string="Constant unimplemented for type"
constant_unimplemented_count=$(grep -rl "$constant_unimplemented_string" . | wc -l)
echo "constant unimplemented errors: $constant_unimplemented_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

external_var_arg_string="Calling external var arg function"
external_var_arg_count=$(grep -rl "$external_var_arg_string" . | wc -l)
echo "external var args errors: $external_var_arg_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

memcpy_string="Invalid call to memcpy()!"
memcpy_count=$(grep -rl "$memcpy_string" . | wc -l)
echo "memcpy errors: $memcpy_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

segfault_string="Segmentation fault"
segfault_count=$(grep -rl "$segfault_string" . | wc -l)
echo "segmentation fault errors: $segfault_count / $file_count" >> ../../test_results/${PROJECT_NAME}_summary.txt

cd ../..
#rm combined.ll combined_old.ll
