#!/usr/bin/env bash
set -euo pipefail

MIXED_LANGUAGE=false
DEPDIR=$(pwd)

# parse flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    --ffi)
      MIXED_LANGUAGE=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# now $1 should be the project path
if [[ $# -lt 1 ]]; then
  echo "Target Cargo Project not supplied. Exiting"
  exit 1
fi

TARGET_RUST_PROJECT=$1

make

echo "pwd is: $(pwd)"

echo "target rust project is: $TARGET_RUST_PROJECT"


#INTEGRATION_TEST_FILES="$DEPDIR/integration_test_files.txt"
#: > "$INTEGRATION_TEST_FILES"

#proj_dir=$(realpath "$TARGET_RUST_PROJECT")

#find "$proj_dir/tests" -type f -name '*.rs' \
#  -printf '%f\n' \
#| sed 's/\.rs$//' \
#| sort -u > "$INTEGRATION_TEST_FILES"


./get_combined_integration_tests_with_deps "$TARGET_RUST_PROJECT"

if [ "$#" -lt 1 ]; then
	echo "Target Cargo Project not supplied. Exiting"
	exit 1
fi

grep -P '^@[^ ]+ = external (thread_local )?global' combined_old.ll \
  | sed -E 's/^@("?[^" =]+).*/\1/' > extern_globals.txt

EXTERNS_ABS="$(realpath extern_globals.txt)"

OLD_PWD="$(pwd)"

cd /home/ollie/Desktop/RustMC/rust/build/x86_64-unknown-linux-gnu

EXTERNS_FILE="$EXTERNS_ABS"

# 1. Dump all symbol tables in parallel
ALL_NM_OUTPUT="$(
  find . -type f \( -name '*.o' -o -name '*.rlib' \) -print0 \
  | xargs -0 -P"$(nproc)" -I{} sh -c '
        f="$1"
        llvm-nm-18 --quiet --defined-only --print-file-name "$f" 2>/dev/null
      ' sh {}
)"

SANITISED_PATTERNS="$(mktemp)"
grep -v '^$' "$EXTERNS_FILE" > "$SANITISED_PATTERNS"

printf '%s\n' "$ALL_NM_OUTPUT" \
| rg -F -f "$SANITISED_PATTERNS" --no-line-number --no-heading \
| cut -d: -f1 \
| sort -u \
| while IFS= read -r p; do realpath "$p"; done \
> matched_files_abs.txt

echo "Matched extern globals in files:"
cat matched_files_abs.txt
echo "\n ------------------------------ \n"

INPUT_LIST="matched_files_abs.txt"

while IFS= read -r rlib; do
  # skip blank lines
  [ -z "$rlib" ] && continue

  # skip if not an .rlib
  case "$rlib" in
    *.rlib) ;;
    *) continue ;;
  esac

  outdir="${rlib%.rlib}.bcdir"
  mkdir -p "$outdir"
  tmp="$(mktemp -d)"

  # extract only .o members into a temp dir
  llvm-ar-18 t "$rlib" | rg '\.o$' | while IFS= read -r m; do
    llvm-ar-18 p "$rlib" "$m" > "$tmp/$m"
  done

  # for each .o, dump embedded bitcode and disassemble
  (
    cd "$tmp"
    find . -type f -name '*.o' -print0 \
    | while IFS= read -r -d '' f; do
        if llvm-readelf-18 -S "$f" | rg -q '\.llvmbc'; then
          b="$outdir/${f#./}"
          b="${b%.o}"
          mkdir -p "$(dirname "$b")"
          llvm-objcopy-18 --dump-section .llvmbc="${b}.bc" "$f"
          llvm-dis-18 "${b}.bc" -o "${b}.ll"
        fi
      done
  )

  # optional: clean temp dir
  rm -rf "$tmp"

done < "$INPUT_LIST"

TMP_RESULTS="$(mktemp)"

grep -v '^$' "$EXTERNS_FILE" | while IFS= read -r sym; do
  # collect all .ll files that mention this symbol
  rg -l --glob '*.ll' -F "$sym" . | while IFS= read -r file; do
    # skip whole file if it has an external decl of this symbol
    # reject both @sym = external ... and @"sym" = external ...
    if rg -q -F "$sym = external" "$file"; then
      continue
    fi
    if rg -q -F "\"$sym\" = external" "$file"; then
      continue
    fi

    # extract candidate lines
    rg -F "$sym" "$file" \
    | rg ' global ' \
    | rg -v -F "$sym = external" \
    | rg -v -F "\"$sym\" = external" \
    | sed -E 's/(align [0-9]+).*$/\1/' \
    >> "$TMP_RESULTS"
  done
done

sort -u "$TMP_RESULTS" > $OLD_PWD/combined_extern_globals_definitions.ll

cd "$OLD_PWD"

tmp="$(mktemp)"
grep -v ' = external' "combined_extern_globals_definitions.ll" > "$tmp"
mv "$tmp" "$OLD_PWD/combined_extern_globals_definitions.ll"

llvm-link-18 -S --internalize --override=combined_extern_globals_definitions.ll -o override/my_pthread.ll override/my_pthread.ll
